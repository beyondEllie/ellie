package configs

import (
	"fmt"
	"os"
	"path/filepath"
	"time"
	"log"

	"github.com/joho/godotenv"
	"github.com/tacheraSasi/ellie/styles"
	"github.com/tacheraSasi/ellie/utils"
)

const (
	configDirName     = "ellie"
	configFileName    = ".ellie.env"
	gitignoreName     = ".gitignore"
	readmeName        = "README.md"
	exampleEnvName    = "config.example.env"
	configVersionFile = "config.version" // Keep track of config versions
)

var (
	ConfigDir  string
	ConfigPath string
)

func init() {
	initConfigPaths()
	ensureConfigStructure()
	Init()
}

func initConfigPaths() {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		styles.ErrorStyle.Println("‚ùå Error: Unable to determine user home directory:", err)
		os.Exit(1)
	}

	ConfigDir = filepath.Join(homeDir, configDirName)
	ConfigPath = filepath.Join(ConfigDir, configFileName)
}

func ensureConfigStructure() {
	// Create config directory with secure permissions
	if err := os.MkdirAll(ConfigDir, 0700); err != nil {
		styles.ErrorStyle.Println("‚ùå Error: Failed to create config directory:", err)
		os.Exit(1)
	}

	// Create security files if they don't exist
	createGitignore()
	createReadme()
	createExampleEnv()
	createVersionFile()
}

func createGitignore() {
	gitignorePath := filepath.Join(ConfigDir, gitignoreName)
	if _, err := os.Stat(gitignorePath); os.IsNotExist(err) {
		content := `# Auto-generated by Ellie CLI
*.env
*.secret
*.key
`
		if err := os.WriteFile(gitignorePath, []byte(content), 0644); err != nil {
			styles.WarningStyle.Println("‚ö†Ô∏è Warning: Failed to create .gitignore:", err)
		}
	}
}

func createReadme() {
	readmePath := filepath.Join(ConfigDir, readmeName)
	if _, err := os.Stat(readmePath); os.IsNotExist(err) {
		content := `# Ellie CLI Configuration Directory

## Files
- .ellie.env: Main configuration file (DO NOT COMMIT THIS!)
- config.example.env: Example configuration template
- .gitignore: Default git ignore rules

## Security
Never commit sensitive information like API keys. Use the provided .gitignore
to protect your credentials.
`
		if err := os.WriteFile(readmePath, []byte(content), 0644); err != nil {
			styles.WarningStyle.Println("‚ö†Ô∏è Warning: Failed to create README:", err)
		}
	}
}

func createExampleEnv() {
	examplePath := filepath.Join(ConfigDir, exampleEnvName)
	if _, err := os.Stat(examplePath); os.IsNotExist(err) {
		content := `# Ellie CLI Configuration Example

USERNAME="your_username"
EMAIL="your@email.com"
OPENAI_API_KEY="sk-...your-openai-key"
RELAY_API_KEY="your-relay-key"
`
		if err := os.WriteFile(examplePath, []byte(content), 0644); err != nil {
			styles.WarningStyle.Println("‚ö†Ô∏è Warning: Failed to create example config:", err)
		}
	}
}

func createVersionFile() {
	versionPath := filepath.Join(ConfigDir, configVersionFile)
	if _, err := os.Stat(versionPath); os.IsNotExist(err) {
		content := "v1.0.0" // Initial version of the config
		if err := os.WriteFile(versionPath, []byte(content), 0644); err != nil {
			styles.WarningStyle.Println("‚ö†Ô∏è Warning: Failed to create version file:", err)
		}
	}
}

func Init() {
	if _, err := os.Stat(ConfigPath); os.IsNotExist(err) {
		createDefaultConfig()
	} else {
		loadExistingConfig()
	}
}

func createDefaultConfig() {
	styles.InfoStyle.Println("üîß Initializing Ellie CLI configuration...")

	config := collectConfiguration()
	backupExistingConfig()

	if err := godotenv.Write(config, ConfigPath); err != nil {
		styles.ErrorStyle.Println("‚ùå Error: Failed to create config file:", err)
		os.Exit(1)
	}

	setFilePermissions()
	styles.SuccessStyle.Printf("‚úÖ Configuration initialized at %s\n", ConfigPath)
}

func collectConfiguration() map[string]string {
	return map[string]string{
		"USERNAME":       getRequiredInput("Username"),
		"EMAIL":          getOptionalInput("Email"),
		"OPENAI_API_KEY": getRequiredInput("OpenAI API Key"),
		"RELAY_API_KEY":  getOptionalInput("EkiliRelay API Key (https://relay.ekilie.com/console)"),
	}
}

func getRequiredInput(prompt string) string {
	for {
		value, err := utils.GetInput(fmt.Sprintf("-> %s: ", prompt))
		if err != nil {
			styles.ErrorStyle.Printf("‚ùå Input error: %v\n", err)
			continue
		}
		if value == "" {
			styles.WarningStyle.Println("‚ö†Ô∏è This field is required")
			continue
		}
		return value
	}
}

func getOptionalInput(prompt string) string {
	value, _ := utils.GetInput(fmt.Sprintf("-> %s (optional): ", prompt))
	return value
}

func backupExistingConfig() {
	if _, err := os.Stat(ConfigPath); err == nil {
		backupPath := fmt.Sprintf("%s.bak.%d", ConfigPath, time.Now().Unix())
		if err := os.Rename(ConfigPath, backupPath); err == nil {
			styles.InfoStyle.Printf("üîß Backed up existing config to %s\n", backupPath)
		}
	}
}

func setFilePermissions() {
	if err := os.Chmod(ConfigPath, 0600); err != nil {
		styles.WarningStyle.Println("‚ö†Ô∏è Warning: Failed to set secure permissions on config file:", err)
	}
}

func loadExistingConfig() {
	if err := godotenv.Load(ConfigPath); err != nil {
		styles.ErrorStyle.Println("‚ùå Error: Failed to load configuration:", err)
		os.Exit(1)
	}
	validateRequiredFields()
}

func validateRequiredFields() {
	required := []string{"USERNAME", "OPENAI_API_KEY"}
	for _, field := range required {
		if GetEnv(field) == "" {
			styles.ErrorStyle.Printf("‚ùå Missing required configuration: %s\n", field)
			styles.InfoStyle.Println("üí° Run 'ellie config reset' to reconfigure")
			os.Exit(1)
		}
	}
}

func GetEnv(key string) string {
	return os.Getenv(key)
}

func ConfigExists() bool {
	_, err := os.Stat(ConfigPath)
	return !os.IsNotExist(err)
}

func ResetConfig() {
	styles.InfoStyle.Println("üîÑ Resetting the configuration...")
	backupExistingConfig()
	// Delete the current configuration file
	if err := os.Remove(ConfigPath); err != nil {
		styles.ErrorStyle.Println("‚ùå Error: Failed to remove config file:", err)
		os.Exit(1)
	}
	createDefaultConfig()
}

func AuditFilePermissions() {
	info, err := os.Stat(ConfigPath)
	if err != nil {
		styles.ErrorStyle.Printf("‚ùå Error: Unable to retrieve file info for %s: %v\n", ConfigPath, err)
		return
	}

	mode := info.Mode().Perm()
	styles.InfoStyle.Printf("üîí Current file permissions for %s: %s\n", ConfigPath, mode)
}

func GetConfigVersion() string {
	versionPath := filepath.Join(ConfigDir, configVersionFile)
	data, err := os.ReadFile(versionPath)
	if err != nil {
		styles.WarningStyle.Println("‚ö†Ô∏è Warning: Unable to read version file:", err)
		return "Unknown Version"
	}
	return string(data)
}
